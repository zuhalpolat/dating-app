(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('ngx-timeago', ['exports', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory(global['ngx-timeago'] = {}, global.ng.core, global.rxjs, global.rxjs.operators));
}(this, (function (exports, core, rxjs, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    function isDefined(value) {
        return typeof value !== 'undefined' && value !== null;
    }
    function coerceBooleanProperty(value) {
        return value != null && "" + value !== 'false';
    }
    function dateParser(date) {
        var parsed = new Date(date);
        if (!Number.isNaN(parsed.valueOf())) {
            return parsed;
        }
        var parts = String(date).match(/\d+/g);
        if (parts === null || parts.length <= 2) {
            return parsed;
        }
        else {
            var _a = __read(parts.map(function (x) { return parseInt(x, 10); })), firstP = _a[0], secondP = _a[1], restPs = _a.slice(2);
            return new Date(Date.UTC.apply(Date, __spread([firstP, secondP - 1], restPs)));
        }
    }
    var MINUTE = 60;
    var HOUR = MINUTE * 60;
    var DAY = HOUR * 24;
    var WEEK = DAY * 7;
    var MONTH = DAY * 30;
    var YEAR = DAY * 365;

    var TimeagoClock = /** @class */ (function () {
        function TimeagoClock() {
        }
        return TimeagoClock;
    }());
    var TimeagoDefaultClock = /** @class */ (function (_super) {
        __extends(TimeagoDefaultClock, _super);
        function TimeagoDefaultClock() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TimeagoDefaultClock.prototype.tick = function (then) {
            return rxjs.of(0)
                .pipe(operators.expand(function () {
                var now = Date.now();
                var seconds = Math.round(Math.abs(now - then) / 1000);
                var period = seconds < MINUTE
                    ? 1000
                    : seconds < HOUR
                        ? 1000 * MINUTE
                        : seconds < DAY
                            ? 1000 * HOUR
                            : 0;
                return period ? rxjs.timer(period) : rxjs.empty();
            }), operators.skip(1));
        };
        return TimeagoDefaultClock;
    }(TimeagoClock));
    TimeagoDefaultClock.decorators = [
        { type: core.Injectable }
    ];

    ;
    /**
     * To modify the text displayed, create a new instance of TimeagoIntl and
     * include it in a custom provider
     */
    var TimeagoIntl = /** @class */ (function () {
        function TimeagoIntl() {
            /**
             * Stream that emits whenever the l10n strings are changed
             * Use this to notify directives if the l10n strings have changed after initialization.
             */
            this.changes = new rxjs.Subject();
        }
        return TimeagoIntl;
    }());
    TimeagoIntl.decorators = [
        { type: core.Injectable }
    ];

    var defaultFormattter = function (then) {
        var now = Date.now();
        var seconds = Math.round(Math.abs(now - then) / 1000);
        var suffix = then < now ? 'ago' : 'from now';
        var _a = __read(seconds < MINUTE
            ? [Math.round(seconds), 'second']
            : seconds < HOUR
                ? [Math.round(seconds / MINUTE), 'minute']
                : seconds < DAY
                    ? [Math.round(seconds / HOUR), 'hour']
                    : seconds < WEEK
                        ? [Math.round(seconds / DAY), 'day']
                        : seconds < MONTH
                            ? [Math.round(seconds / WEEK), 'week']
                            : seconds < YEAR
                                ? [Math.round(seconds / MONTH), 'month']
                                : [Math.round(seconds / YEAR), 'year'], 2), value = _a[0], unit = _a[1];
        return { value: value, unit: unit, suffix: suffix };
    };
    var ɵ0 = defaultFormattter;
    var TimeagoFormatter = /** @class */ (function () {
        function TimeagoFormatter() {
        }
        return TimeagoFormatter;
    }());
    var TimeagoDefaultFormatter = /** @class */ (function (_super) {
        __extends(TimeagoDefaultFormatter, _super);
        function TimeagoDefaultFormatter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TimeagoDefaultFormatter.prototype.format = function (then) {
            var _a = defaultFormattter(then), suffix = _a.suffix, value = _a.value, unit = _a.unit;
            return this.parse(value, unit, suffix);
        };
        TimeagoDefaultFormatter.prototype.parse = function (value, unit, suffix) {
            if (value !== 1) {
                unit += 's';
            }
            return value + ' ' + unit + ' ' + suffix;
        };
        return TimeagoDefaultFormatter;
    }(TimeagoFormatter));
    TimeagoDefaultFormatter.decorators = [
        { type: core.Injectable }
    ];
    var TimeagoCustomFormatter = /** @class */ (function (_super) {
        __extends(TimeagoCustomFormatter, _super);
        function TimeagoCustomFormatter(intl) {
            var _this = _super.call(this) || this;
            _this.intl = intl;
            return _this;
        }
        TimeagoCustomFormatter.prototype.format = function (then) {
            var _a = defaultFormattter(then), suffix = _a.suffix, value = _a.value, unit = _a.unit;
            return this.parse(value, unit, suffix, Date.now(), then);
        };
        TimeagoCustomFormatter.prototype.parse = function (value, unit, suffix, now, then) {
            /** convert weeks to days if strings don't handle weeks */
            if (unit === 'week' && !this.intl.strings.week && !this.intl.strings.weeks) {
                var days = Math.round(Math.abs(now - then) / (1000 * 60 * 60 * 24));
                value = days;
                unit = 'day';
            }
            /** create a normalize function for given value */
            var normalize = this.normalizeFn(value, now - then, this.intl.strings.numbers);
            /** The eventual return value stored in an array so that the wordSeparator can be used */
            var dateString = [];
            /** handle prefixes */
            if (suffix === 'ago' && this.intl.strings.prefixAgo) {
                dateString.push(normalize(this.intl.strings.prefixAgo));
            }
            if (suffix === 'from now' && this.intl.strings.prefixFromNow) {
                dateString.push(normalize(this.intl.strings.prefixFromNow));
            }
            /** Handle Main number and unit */
            var isPlural = value > 1;
            if (isPlural) {
                var stringFn = this.intl.strings[unit + 's'] || this.intl.strings[unit] || '%d ' + unit;
                dateString.push(normalize(stringFn));
            }
            else {
                var stringFn = this.intl.strings[unit] || this.intl.strings[unit + 's'] || '%d ' + unit;
                dateString.push(normalize(stringFn));
            }
            /** Handle Suffixes */
            if (suffix === 'ago' && this.intl.strings.suffixAgo) {
                dateString.push(normalize(this.intl.strings.suffixAgo));
            }
            if (suffix === 'from now' && this.intl.strings.suffixFromNow) {
                dateString.push(normalize(this.intl.strings.suffixFromNow));
            }
            /** join the array into a string and return it */
            var wordSeparator = typeof this.intl.strings.wordSeparator === 'string' ? this.intl.strings.wordSeparator : ' ';
            return dateString.join(wordSeparator);
        };
        /**
         * If the numbers array is present, format numbers with it,
         * otherwise just cast the number to a string and return it
        */
        TimeagoCustomFormatter.prototype.normalizeNumber = function (numbers, value) {
            return numbers && numbers.length === 10
                ? String(value).split('')
                    .map(function (digit) { return digit.match(/^[0-9]$/) ? numbers[parseInt(digit, 10)] : digit; })
                    .join('')
                : String(value);
        };
        /**
         * Take a string or a function that takes number of days and returns a string
         * and provide a uniform API to create string parts
        */
        TimeagoCustomFormatter.prototype.normalizeFn = function (value, millisDelta, numbers) {
            var _this = this;
            return function (stringOrFn) { return typeof stringOrFn === 'function'
                ? stringOrFn(value, millisDelta).replace(/%d/g, _this.normalizeNumber(numbers, value))
                : stringOrFn.replace(/%d/g, _this.normalizeNumber(numbers, value)); };
        };
        return TimeagoCustomFormatter;
    }(TimeagoFormatter));
    TimeagoCustomFormatter.decorators = [
        { type: core.Injectable }
    ];
    TimeagoCustomFormatter.ctorParameters = function () { return [
        { type: TimeagoIntl }
    ]; };

    var TimeagoDirective = /** @class */ (function () {
        function TimeagoDirective(intl, cd, formatter, element, clock) {
            var _this = this;
            this.cd = cd;
            this.clock = clock;
            /**
             * Emits on:
             * - Input change
             * - Intl change
             * - Clock tick
            */
            this.stateChanges = new rxjs.Subject();
            this._live = true;
            if (intl) {
                this.intlSubscription = intl.changes.subscribe(function () { return _this.stateChanges.next(); });
            }
            this.stateChanges.subscribe(function () {
                _this.setContent(element.nativeElement, formatter.format(_this.date));
                _this.cd.markForCheck();
            });
        }
        Object.defineProperty(TimeagoDirective.prototype, "date", {
            /** The Date to display. An actual Date object or something that can be fed to new Date. */
            get: function () {
                return this._date;
            },
            set: function (date) {
                var _this = this;
                this._date = dateParser(date).valueOf();
                if (this._date) {
                    if (this.clockSubscription) {
                        this.clockSubscription.unsubscribe();
                        this.clockSubscription = undefined;
                    }
                    this.clockSubscription = this.clock.tick(this.date)
                        .pipe(operators.filter(function () { return _this.live; }, this))
                        .subscribe(function () { return _this.stateChanges.next(); });
                }
                else {
                    throw new SyntaxError("Wrong parameter in TimeagoDirective. Expected a valid date, received: " + date);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TimeagoDirective.prototype, "live", {
            /** If the directive should update itself over time */
            get: function () {
                return this._live;
            },
            set: function (live) {
                this._live = coerceBooleanProperty(live);
            },
            enumerable: false,
            configurable: true
        });
        TimeagoDirective.prototype.ngOnChanges = function () {
            this.stateChanges.next();
        };
        TimeagoDirective.prototype.setContent = function (node, content) {
            if (isDefined(node.textContent)) {
                node.textContent = content;
            }
            else {
                node.data = content;
            }
        };
        TimeagoDirective.prototype.ngOnDestroy = function () {
            if (this.intlSubscription) {
                this.intlSubscription.unsubscribe();
                this.intlSubscription = undefined;
            }
            if (this.clockSubscription) {
                this.clockSubscription.unsubscribe();
                this.clockSubscription = undefined;
            }
            this.stateChanges.complete();
        };
        return TimeagoDirective;
    }());
    TimeagoDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[timeago]',
                    exportAs: 'timeago',
                },] }
    ];
    TimeagoDirective.ctorParameters = function () { return [
        { type: TimeagoIntl, decorators: [{ type: core.Optional }] },
        { type: core.ChangeDetectorRef },
        { type: TimeagoFormatter },
        { type: core.ElementRef },
        { type: TimeagoClock }
    ]; };
    TimeagoDirective.propDecorators = {
        date: [{ type: core.Input }],
        live: [{ type: core.Input }]
    };

    var TimeagoPipe = /** @class */ (function () {
        function TimeagoPipe(intl, cd, formatter, clock) {
            var _this = this;
            this.clock = clock;
            this.live = true;
            /**
             * Emits on:
             * - Input change
             * - Intl change
             * - Clock tick
            */
            this.stateChanges = new rxjs.Subject();
            if (intl) {
                this.intlSubscription = intl.changes.subscribe(function () { return _this.stateChanges.next(); });
            }
            this.stateChanges.subscribe(function () {
                _this.value = formatter.format(_this.date);
                cd.markForCheck();
            });
        }
        TimeagoPipe.prototype.transform = function (date) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _date = dateParser(date).valueOf();
            var _live;
            _live = isDefined(args[0])
                ? coerceBooleanProperty(args[0])
                : this.live;
            if (this.date === _date && this.live === _live) {
                return this.value;
            }
            this.date = _date;
            this.live = _live;
            if (this.date) {
                if (this.clockSubscription) {
                    this.clockSubscription.unsubscribe();
                    this.clockSubscription = undefined;
                }
                this.clockSubscription = this.clock.tick(this.date)
                    .pipe(operators.filter(function () { return _this.live; }, this))
                    .subscribe(function () { return _this.stateChanges.next(); });
                this.stateChanges.next();
            }
            else {
                throw new SyntaxError("Wrong parameter in TimeagoPipe. Expected a valid date, received: " + date);
            }
            return this.value;
        };
        TimeagoPipe.prototype.ngOnDestroy = function () {
            if (this.intlSubscription) {
                this.intlSubscription.unsubscribe();
                this.intlSubscription = undefined;
            }
            if (this.clockSubscription) {
                this.clockSubscription.unsubscribe();
                this.clockSubscription = undefined;
            }
            this.stateChanges.complete();
        };
        return TimeagoPipe;
    }());
    TimeagoPipe.decorators = [
        { type: core.Injectable },
        { type: core.Pipe, args: [{
                    name: 'timeago',
                    pure: false,
                },] }
    ];
    TimeagoPipe.ctorParameters = function () { return [
        { type: TimeagoIntl, decorators: [{ type: core.Optional }] },
        { type: core.ChangeDetectorRef },
        { type: TimeagoFormatter },
        { type: TimeagoClock }
    ]; };

    var TimeagoModule = /** @class */ (function () {
        function TimeagoModule() {
        }
        /**
         * Use this method in your root module to provide the TimeagoModule
         */
        TimeagoModule.forRoot = function (config) {
            if (config === void 0) { config = {}; }
            return {
                ngModule: TimeagoModule,
                providers: [
                    config.clock || { provide: TimeagoClock, useClass: TimeagoDefaultClock },
                    config.intl || [],
                    config.formatter || { provide: TimeagoFormatter, useClass: TimeagoDefaultFormatter },
                ],
            };
        };
        /**
         * Use this method in your other (non root) modules to import the directive/pipe
         */
        TimeagoModule.forChild = function (config) {
            if (config === void 0) { config = {}; }
            return {
                ngModule: TimeagoModule,
                providers: [
                    config.clock || { provide: TimeagoClock, useClass: TimeagoDefaultClock },
                    config.intl || [],
                    config.formatter || { provide: TimeagoFormatter, useClass: TimeagoDefaultFormatter },
                ],
            };
        };
        return TimeagoModule;
    }());
    TimeagoModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [
                        TimeagoDirective,
                        TimeagoPipe,
                    ],
                    exports: [
                        TimeagoDirective,
                        TimeagoPipe,
                    ],
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.TimeagoClock = TimeagoClock;
    exports.TimeagoCustomFormatter = TimeagoCustomFormatter;
    exports.TimeagoDefaultClock = TimeagoDefaultClock;
    exports.TimeagoDefaultFormatter = TimeagoDefaultFormatter;
    exports.TimeagoDirective = TimeagoDirective;
    exports.TimeagoFormatter = TimeagoFormatter;
    exports.TimeagoIntl = TimeagoIntl;
    exports.TimeagoModule = TimeagoModule;
    exports.TimeagoPipe = TimeagoPipe;
    exports.ɵ0 = ɵ0;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-timeago.umd.js.map
